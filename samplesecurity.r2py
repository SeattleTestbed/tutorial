"""
This security layer interposes size restrictions on a textfile.
The security layer comes into play when a user tries to write data on a text file. There are three cases here:

- If data on file goes beyond the permitted file size, then extra data would be truncated and remaining would be written on file
- If data to be written is less than the size specified, then "0"s would be written till file is of specified size
- If someone tries to write at the place of specified size, an error would be raised. For example if the permitted file size is 10 and someone tries to write on file with offset 10 or larger then it will raise an error



For efficiency purposes, you *MUST NOT* call readat inside of writeat.   It
is fine to call readat during file open if desired.


Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    This security layer never runs explicitly but instead interposes functions
    from above layers.
    
    """ 


TYPE="type"
ARGS="args"
RETURN="return"
EXCP="exceptions"
TARGET="target"
FUNC="func"
OBJC="objc"

class SecureFile():
  def __init__(self,file):
    # globals
    mycontext['debug'] = False   
    mycontext['size'] = 0
    mycontext['filesizesetflag'] = False 
    # local (per object) reference to the underlying file
    self.file = file

  def setmaxfilesize(self,size):

    #raise value error if specified size is negative
    if size<0:
      raise ValueError

    #truncate if file size is already more than specifies size.
    data = self.file.readat(None,0)
    if len(data)>size:
      self.close()
      removefile("look.txt")
      file = self.openfile("look.txt",True)
      self.__init__(file)
      extra_size = len(data) - size
      data = data[0:-extra_size]
      self.file.writeat(data,0)
    mycontext['size'] = size
    mycontext['filesizesetflag'] = True

  def writeat(self,data,offset):
    # check if setmaxfilesize() has been called before or not. Will act upon file size actions only if the fla for setmaxfilesize is set.
    if mycontext['filesizesetflag'] != True:
      self.file.writeat(data,offset)
    else:
      datalen = len(data)
      size_after_data = datalen + offset 
      size_diff = abs(size_after_data - mycontext['size'])

      #raise error if user try to write beyond permitted file size
      if offset >= mycontext['size']:
        raise ValueError

      #truncate data if its starting position is within size but data goes beyond permitted file  size
      elif size_after_data > mycontext['size']:
        data = data [0:-size_diff]
        self.file.writeat(data,offset)

      #fill out the remaining places with zeros to make file of required size 
      elif size_after_data < mycontext['size']:
        self.file.writeat(data,offset)
        while size_after_data < mycontext['size']:
          self.file.writeat("0",size_after_data)
          size_after_data = size_after_data+1

  def readat(self,bytes,offset):
    return self.file.readat(bytes,offset)

  def openfile(self,filename,create):
    file = openfile(filename,create)
    return file
    
    
  def removefile(filename):
    removefile(filename)

  def close(self):
    return self.file.close()

sec_file_def = {"obj-type":SecureFile,
                "name":"SecureFile",
                "setmaxfilesize":{TYPE:FUNC,ARGS:[int],EXCP:Exception,RETURN:(type(None)),TARGET:SecureFile.setmaxfilesize},
                "removefile":{TYPE:FUNC,ARGS:(str),EXCP:Exception,RETURN:(type(None)),TARGET:SecureFile.removefile},
                "openfile":{TYPE:FUNC,ARGS:(str,bool),EXCP:Exception,RETURN:(type(file)),TARGET:SecureFile.openfile},
                "writeat":{TYPE:FUNC,ARGS:(str,(int,long)),EXCP:Exception,RETURN:(int,type(None)),TARGET:SecureFile.writeat},
                "readat":{TYPE:FUNC,ARGS:((int,long,type(None)),(int,long)),EXCP:Exception,RETURN:str,TARGET:SecureFile.readat},
                "close":{TYPE:FUNC,ARGS:None,EXCP:None,RETURN:(bool,type(None)),TARGET:SecureFile.close}
           }

def secure_openfile(filename, create):
  f = openfile(filename,create)
  return SecureFile(f)

CHILD_CONTEXT_DEF["openfile"] = {TYPE:OBJC,ARGS:(str,bool),EXCP:Exception,RETURN:sec_file_def,TARGET:secure_openfile}

secure_dispatch_module()
